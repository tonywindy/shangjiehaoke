<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‘¨é•¿çš„æ¢ç´¢ä¹‹æ—…</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Soft Pastels -->
    <!-- Application Structure Plan: A linear, three-step SPA guided by a top navigation bar. Each step corresponds to a learning module from the source document, displayed in a dedicated content area. This structure directly follows the pedagogical flow of the report, ensuring a logical and easy-to-follow learning journey for young students. Key interactions involve canvas-based animations for conceptual understanding and direct manipulation of elements for exploration. -->
    <!-- Visualization & Content Choices: Module 1 (Concept): Uses a Canvas to animate an 'ant' tracing a shape's perimeter and simulates 'unrolling' it into a line, visually defining the concept. Module 2 (Conservation): Uses a Canvas with draggable points to form various shapes from a fixed-length line, demonstrating that perimeter remains constant. Module 3 (Formula): Uses HTML/CSS transforms to visually deconstruct a rectangle, explaining the (L+W)*2 formula. This avoids SVG/Mermaid and uses the best tool (Canvas for dynamic drawing, HTML for block layout) for each pedagogical goal. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #F0F4F8; /* Light Blue-Gray */
        }
        .nav-item {
            transition: all 0.3s ease;
            border-bottom-width: 4px;
        }
        .nav-item.active {
            color: #3B82F6; /* Blue-500 */
            border-color: #3B82F6;
        }
        .nav-item:not(.active) {
            border-color: transparent;
        }
        .shape-card {
            transition: all 0.2s ease-in-out;
        }
        .shape-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .control-button {
            transition: all 0.2s ease-in-out;
        }
        .control-button:hover {
            transform: scale(1.05);
        }
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .unrolled-line {
            transition: width 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #module-3-grid {
            background-image:
                linear-gradient(to right, #D1D5DB 1px, transparent 1px),
                linear-gradient(to bottom, #D1D5DB 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .resizable-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: #3B82F6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-4 md:p-8">

    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800">å‘¨é•¿çš„æ¢ç´¢ä¹‹æ—…</h1>
            <p class="text-gray-500 mt-2">é€šè¿‡äº’åŠ¨å‘ç°å‘¨é•¿çš„å¥¥ç§˜ï¼</p>
        </header>

        <nav class="flex justify-center bg-white rounded-xl shadow-md p-2 mb-8">
            <button id="nav-1" class="nav-item active flex-1 text-center font-bold text-lg p-3 cursor-pointer" onclick="app.navigateTo(1)">
                1. ä»€ä¹ˆæ˜¯å‘¨é•¿ï¼Ÿ
            </button>
            <button id="nav-2" class="nav-item flex-1 text-center font-bold text-lg p-3 cursor-pointer" onclick="app.navigateTo(2)">
                2. ç¥å¥‡çš„ç»³å­
            </button>
            <button id="nav-3" class="nav-item flex-1 text-center font-bold text-lg p-3 cursor-pointer" onclick="app.navigateTo(3)">
                3. é•¿æ–¹å½¢çš„ç§˜å¯†
            </button>
        </nav>

        <main id="app-content" class="bg-white rounded-2xl shadow-lg p-4 md:p-8 min-h-[60vh] w-full">
            
            <!-- æ¨¡å—ä¸€ï¼šå‘¨é•¿çš„æœ¬è´¨ -->
            <div id="module-1" class="module-content">
                <div id="m1-gallery" class="text-center">
                    <h2 class="text-2xl font-bold mb-1 text-gray-700">ç¬¬ä¸€ç«™ï¼šå›¾å½¢é™ˆåˆ—é¦†</h2>
                    <p class="text-gray-500 mb-6">è¯·é€‰æ‹©ä¸€ä¸ªä½ æ„Ÿå…´è¶£çš„å›¾å½¢ï¼Œçœ‹çœ‹å®ƒçš„å‘¨é•¿æ˜¯ä»€ä¹ˆæ ·çš„ã€‚</p>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <!-- Shapes will be injected by JS -->
                    </div>
                </div>
                <div id="m1-focus" class="hidden flex flex-col items-center">
                    <div id="m1-canvas-container" class="w-full max-w-md h-80 bg-gray-50 rounded-lg mb-4 relative">
                        <canvas id="m1-canvas"></canvas>
                    </div>
                    <div id="m1-controls" class="flex items-center gap-4 mb-4">
                        <button id="m1-start-btn" class="control-button bg-blue-500 text-white font-bold py-2 px-5 rounded-full shadow-lg">å¼€å§‹æ¼”ç¤º</button>
                        <button id="m1-pause-btn" class="control-button bg-yellow-500 text-white font-bold py-2 px-5 rounded-full shadow-lg hidden">æš‚åœ</button>
                        <button id="m1-unroll-btn" class="control-button bg-green-500 text-white font-bold py-2 px-5 rounded-full shadow-lg" disabled>å±•å¼€å‘¨é•¿</button>
                        <button id="m1-back-btn" class="control-button bg-gray-400 text-white font-bold py-2 px-5 rounded-full shadow-lg">è¿”å›</button>
                    </div>
                    <div id="m1-result-container" class="w-full max-w-md h-16 text-center">
                        <p id="m1-result-text" class="text-lg font-semibold text-gray-600 h-8"></p>
                        <div id="m1-unrolled-line-wrapper" class="h-8 flex items-center justify-center relative overflow-hidden"></div>
                    </div>
                </div>
            </div>

            <!-- æ¨¡å—äºŒï¼šå‘¨é•¿å®ˆæ’ -->
            <div id="module-2" class="module-content hidden">
                <h2 class="text-2xl font-bold mb-1 text-center text-gray-700">ç¬¬äºŒç«™ï¼šç»³å­å˜é­”æœ¯</h2>
                <p class="text-gray-500 mb-4 text-center">æ‹–åŠ¨ç»³å­ä¸Šçš„åœ†ç‚¹ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆç¥å¥‡çš„äº‹æƒ…ï¼</p>
                <div class="flex flex-col md:flex-row items-center gap-6">
                    <div id="m2-canvas-container" class="w-full md:w-2/3 h-96 bg-gray-50 rounded-lg relative">
                        <canvas id="m2-canvas"></canvas>
                    </div>
                    <div class="w-full md:w-1/3 text-center p-4 bg-blue-100 rounded-lg">
                        <h3 class="text-xl font-bold text-blue-800">å‘¨é•¿æŒ‡ç¤ºå™¨</h3>
                        <p class="text-5xl font-mono font-extrabold text-blue-600 my-4" id="m2-perimeter-display">24.0</p>
                        <p class="text-blue-700">æ— è®ºå½¢çŠ¶æ€ä¹ˆå˜ï¼Œå‘¨é•¿ï¼ˆç»³å­çš„æ€»é•¿åº¦ï¼‰æ˜¯**ä¸å˜**çš„ï¼</p>
                        <div class="mt-4 flex flex-col gap-2">
                            <button class="control-button bg-white text-blue-600 font-semibold py-2 px-4 rounded-lg border-2 border-blue-300" onclick="modules.module2.setShape('rect')">å˜æˆé•¿æ–¹å½¢</button>
                            <button class="control-button bg-white text-blue-600 font-semibold py-2 px-4 rounded-lg border-2 border-blue-300" onclick="modules.module2.setShape('circle')">å˜æˆåœ†å½¢</button>
                             <button class="control-button bg-white text-blue-600 font-semibold py-2 px-4 rounded-lg border-2 border-blue-300" onclick="modules.module2.reset()">é‡ç½®ä¸ºç›´çº¿</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ¨¡å—ä¸‰ï¼šé•¿æ–¹å½¢çš„ç§˜å¯† -->
            <div id="module-3" class="module-content hidden">
                <h2 class="text-2xl font-bold mb-1 text-center text-gray-700">ç¬¬ä¸‰ç«™ï¼šé•¿æ–¹å½¢çš„ç§˜å¯†</h2>
                <p class="text-gray-500 mb-4 text-center">æ‹–åŠ¨å³ä¸‹è§’çš„è“è‰²åœ†ç‚¹å¯ä»¥æ”¹å˜å¤§å°ï¼Œçœ‹çœ‹å‘¨é•¿å…¬å¼æ˜¯æ€ä¹ˆæ¥çš„ã€‚</p>
                <div class="flex flex-col md:flex-row items-center gap-6">
                    <div class="w-full md:w-2/3 h-96 relative flex items-center justify-center" id="m3-container">
                        <div id="m3-grid" class="absolute inset-0 opacity-50"></div>
                        <div id="m3-rect-container" class="relative">
                           <div id="m3-rect" class="bg-blue-300 border-2 border-blue-600 relative" style="width: 240px; height: 160px;">
                                <div id="m3-handle" class="resizable-handle -right-2 -bottom-2"></div>
                                <div id="m3-length-label" class="absolute -top-6 left-1/2 -translate-x-1/2 bg-white px-2 rounded text-blue-800 font-bold"></div>
                                <div id="m3-width-label" class="absolute -left-8 top-1/2 -translate-y-1/2 bg-white px-2 rounded text-green-800 font-bold rotate-[-90deg]"></div>
                           </div>
                        </div>
                    </div>
                    <div class="w-full md:w-1/3 text-center p-4 bg-green-100 rounded-lg">
                        <h3 class="text-xl font-bold text-green-800">å‘¨é•¿è®¡ç®—å…¬å¼</h3>
                        <div class="flex gap-2 mb-3 justify-center">
                            <button id="m3-rect-mode" class="control-button bg-green-500 text-white font-semibold py-1 px-3 rounded-lg text-sm">é•¿æ–¹å½¢</button>
                            <button id="m3-square-mode" class="control-button bg-white text-green-600 font-semibold py-1 px-3 rounded-lg border-2 border-green-300 text-sm">æ­£æ–¹å½¢</button>
                        </div>
                        <div id="m3-formula" class="text-lg font-semibold text-green-700 my-4 h-24 flex flex-col justify-center">
                            <!-- Formula will be injected here -->
                        </div>
                        <button id="m3-demo-btn" class="control-button bg-green-500 text-white font-bold py-2 px-5 rounded-full shadow-lg">æ¼”ç¤ºå…¬å¼</button>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <script>
        const modules = {};

        const app = {
            state: {
                currentModule: 1,
            },
            init() {
                this.navigateTo(1);
                modules.module1.init();
                modules.module2.init();
                modules.module3.init();
            },
            navigateTo(moduleNumber) {
                this.state.currentModule = moduleNumber;
                document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
                document.getElementById(`nav-${moduleNumber}`).classList.add('active');
                
                document.querySelectorAll('.module-content').forEach(module => module.classList.add('hidden'));
                document.getElementById(`module-${moduleNumber}`).classList.remove('hidden');

                // Re-initialize or update module state if needed
                if (moduleNumber === 1) modules.module1.reset();
                if (moduleNumber === 2) modules.module2.reset();
                if (moduleNumber === 3) modules.module3.updateLabels();
            }
        };

        // --- æ¨¡å—ä¸€ï¼šå‘¨é•¿çš„æœ¬è´¨ ---
        modules.module1 = (() => {
            const gallery = document.getElementById('m1-gallery');
            const focusView = document.getElementById('m1-focus');
            const canvas = document.getElementById('m1-canvas');
            const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('m1-start-btn');
            const pauseBtn = document.getElementById('m1-pause-btn');
            const unrollBtn = document.getElementById('m1-unroll-btn');
            const backBtn = document.getElementById('m1-back-btn');
            const resultText = document.getElementById('m1-result-text');
            const lineWrapper = document.getElementById('m1-unrolled-line-wrapper');

            let animationFrameId;
            let isPaused = false;
            let progress = 0;
            let currentShape;

            const shapes = {
                square: { name: 'æ­£æ–¹å½¢', path: (w, h) => [[w*0.2, h*0.2], [w*0.8, h*0.2], [w*0.8, h*0.8], [w*0.2, h*0.8]] },
                rectangle: { name: 'é•¿æ–¹å½¢', path: (w, h) => [[w*0.15, h*0.3], [w*0.85, h*0.3], [w*0.85, h*0.7], [w*0.15, h*0.7]] },
                triangle: { name: 'ä¸‰è§’å½¢', path: (w, h) => [[w*0.5, h*0.15], [w*0.85, h*0.85], [w*0.15, h*0.85]] },
                cloud: { name: 'äº‘æœµ', path: (w, h) => {
                    const points = [];
                    for (let i = 0; i < Math.PI * 2; i += 0.1) {
                        const x = w/2 + (w/3 + Math.sin(i*5) * w/10) * Math.cos(i);
                        const y = h/2 + (h/4 + Math.sin(i*6) * h/12) * Math.sin(i);
                        points.push([x, y]);
                    }
                    return points;
                }}
            };

            function getPathLength(path) {
                let length = 0;
                for (let i = 0; i < path.length; i++) {
                    const p1 = path[i];
                    const p2 = path[(i + 1) % path.length];
                    length += Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);
                }
                return length;
            }

            function getPointAtLength(path, length) {
                let travelled = 0;
                for (let i = 0; i < path.length; i++) {
                    const p1 = path[i];
                    const p2 = path[(i + 1) % path.length];
                    const segmentLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);
                    if (travelled + segmentLength >= length) {
                        const remaining = length - travelled;
                        const ratio = remaining / segmentLength;
                        return {
                            x: p1[0] + (p2[0] - p1[0]) * ratio,
                            y: p1[1] + (p2[1] - p1[1]) * ratio,
                        };
                    }
                    travelled += segmentLength;
                }
                return { x: path[0][0], y: path[0][1] };
            }

            function drawShape(path, color = '#60A5FA', progress = 1) {
                ctx.beginPath();
                ctx.moveTo(path[0][0], path[0][1]);
                let travelled = 0;
                const totalLength = getPathLength(path) * progress;
                for (let i = 0; i < path.length; i++) {
                    const p1 = path[i];
                    const p2 = path[(i + 1) % path.length];
                    const segmentLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);
                    if (travelled + segmentLength > totalLength) {
                        const remaining = totalLength - travelled;
                        const ratio = remaining / segmentLength;
                        const endX = p1[0] + (p2[0] - p1[0]) * ratio;
                        const endY = p1[1] + (p2[1] - p1[1]) * ratio;
                        ctx.lineTo(endX, endY);
                        break;
                    }
                    ctx.lineTo(p2[0], p2[1]);
                    travelled += segmentLength;
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                ctx.stroke();
            }

            function animate() {
                if (isPaused) return;
                progress += 0.005;
                if (progress > 1) {
                    progress = 1;
                    cancelAnimationFrame(animationFrameId);
                    startBtn.classList.add('hidden');
                    pauseBtn.classList.add('hidden');
                    unrollBtn.disabled = false;
                    resultText.textContent = `å°èš‚èšèµ°å®Œäº†ä¸€åœˆï¼å‘¨é•¿æ˜¯ ${currentShape.length.toFixed(1)} åƒç´ ã€‚`;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShape(currentShape.path, '#D1D5DB'); // Draw base shape
                drawShape(currentShape.path, '#EF4444', progress); // Draw progress
                
                const antPos = getPointAtLength(currentShape.path, currentShape.length * progress);
                ctx.fillStyle = 'black';
                ctx.font = '24px sans-serif';
                ctx.fillText('ğŸœ', antPos.x - 12, antPos.y + 8);

                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animate);
                }
            }

            function selectShape(shapeKey) {
                currentShape = {
                    key: shapeKey,
                    ...shapes[shapeKey]
                };
                gallery.classList.add('hidden');
                focusView.classList.remove('hidden');
                
                const container = document.getElementById('m1-canvas-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                currentShape.path = shapes[shapeKey].path(canvas.width, canvas.height);
                currentShape.length = getPathLength(currentShape.path);
                
                resetAnimation();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShape(currentShape.path, '#D1D5DB');
            }

            function resetAnimation() {
                cancelAnimationFrame(animationFrameId);
                progress = 0;
                isPaused = false;
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
                startBtn.textContent = 'å¼€å§‹æ¼”ç¤º';
                unrollBtn.disabled = true;
                resultText.textContent = '';
                lineWrapper.innerHTML = '';
            }

            function unrollPerimeter() {
                resultText.textContent = `å‘¨é•¿å±•å¼€åï¼Œå°±æ˜¯è¿™æ ·ä¸€æ¡ç›´çº¿ï¼`;
                
                // åˆ›å»ºå¤šä¸ªçº¿æ®µç‰‡æ®µï¼Œæ¨¡æ‹Ÿä»å›¾å½¢è¾¹ç•Œå‰¥ç¦»
                const segments = [];
                const numSegments = 6; // åˆ†æˆ6æ®µ
                const path = currentShape.path;
                const totalLength = currentShape.length;
                
                // æ¸…ç©ºä¹‹å‰çš„å†…å®¹
                lineWrapper.innerHTML = '';
                
                // è®¡ç®—å®¹å™¨å’Œç”»å¸ƒçš„ç›¸å¯¹ä½ç½®
                const canvasRect = canvas.getBoundingClientRect();
                const wrapperRect = lineWrapper.getBoundingClientRect();
                
                // ä¸ºæ¯ä¸ªçº¿æ®µåˆ›å»ºDOMå…ƒç´ 
                for (let i = 0; i < numSegments; i++) {
                    const segment = document.createElement('div');
                    segment.className = 'absolute h-2 bg-red-500 rounded-full transition-all duration-1500 ease-out';
                    const segmentWidth = Math.min(totalLength / numSegments * 0.2, 40); // é™åˆ¶æœ€å¤§å®½åº¦
                    segment.style.width = `${segmentWidth}px`;
                    segment.style.opacity = '0';
                    segment.style.zIndex = '10';
                    lineWrapper.appendChild(segment);
                    segments.push(segment);
                }
                
                // é€ä¸ªæ˜¾ç¤ºçº¿æ®µï¼Œæ¨¡æ‹Ÿä»å›¾å½¢å‰¥ç¦»çš„æ•ˆæœ
                segments.forEach((segment, index) => {
                    setTimeout(() => {
                        // è®¡ç®—çº¿æ®µåœ¨å›¾å½¢ä¸Šçš„ä½ç½®
                        const segmentProgress = (index + 0.5) / numSegments;
                        const pos = getPointAtLength(path, totalLength * segmentProgress);
                        
                        // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆç›¸å¯¹äºå®¹å™¨çš„ä½ç½®ï¼‰
                        const initialX = pos.x - (wrapperRect.left - canvasRect.left);
                        const initialY = pos.y - (wrapperRect.top - canvasRect.top) - 100; // ä»ç”»å¸ƒä½ç½®å¼€å§‹
                        
                        segment.style.left = `${initialX}px`;
                        segment.style.top = `${initialY}px`;
                        segment.style.opacity = '1';
                        
                        // å»¶è¿Ÿåç§»åŠ¨åˆ°æœ€ç»ˆä½ç½®
                        setTimeout(() => {
                            const finalX = index * (parseInt(segment.style.width) + 4) + 10;
                            segment.style.left = `${finalX}px`;
                            segment.style.top = '8px'; // å±…ä¸­æ˜¾ç¤º
                            segment.style.transform = 'rotate(0deg)';
                        }, 500);
                        
                    }, index * 200);
                });
            }

            function init() {
                for (const key in shapes) {
                    const card = document.createElement('div');
                    card.className = 'shape-card bg-white p-4 rounded-lg shadow cursor-pointer flex flex-col items-center justify-center aspect-square';
                    card.innerHTML = `<canvas id="thumb-${key}" width="100" height="100"></canvas><p class="font-semibold mt-2">${shapes[key].name}</p>`;
                    card.onclick = () => selectShape(key);
                    gallery.querySelector('.grid').appendChild(card);
                    
                    const thumbCanvas = document.getElementById(`thumb-${key}`);
                    const thumbCtx = thumbCanvas.getContext('2d');
                    const thumbPath = shapes[key].path(100, 100);
                    thumbCtx.beginPath();
                    thumbCtx.moveTo(thumbPath[0][0], thumbPath[0][1]);
                    for(let i = 1; i < thumbPath.length; i++) thumbCtx.lineTo(thumbPath[i][0], thumbPath[i][1]);
                    thumbCtx.closePath();
                    thumbCtx.strokeStyle = '#60A5FA';
                    thumbCtx.lineWidth = 3;
                    thumbCtx.stroke();
                }

                startBtn.onclick = () => {
                    isPaused = false;
                    startBtn.classList.add('hidden');
                    pauseBtn.classList.remove('hidden');
                    animate();
                };
                pauseBtn.onclick = () => {
                    isPaused = !isPaused;
                    pauseBtn.textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';
                    if (!isPaused) animate();
                };
                backBtn.onclick = () => reset();
                unrollBtn.onclick = () => {
                    unrollPerimeter();
                };
            }
            
            function reset() {
                resetAnimation();
                gallery.classList.remove('hidden');
                focusView.classList.add('hidden');
            }

            return { init, reset };
        })();

        // --- æ¨¡å—äºŒï¼šå‘¨é•¿å®ˆæ’ ---
        modules.module2 = (() => {
            const canvas = document.getElementById('m2-canvas');
            const ctx = canvas.getContext('2d');
            const perimeterDisplay = document.getElementById('m2-perimeter-display');
            const FIXED_PERIMETER = 400; // å›ºå®šå‘¨é•¿
            let points = [];
            let draggingPoint = null;
            let draggingIndex = -1;

            function init() {
                const container = document.getElementById('m2-canvas-container');
                // è®¾ç½®Canvaså°ºå¯¸
                canvas.width = container.clientWidth || 400;
                canvas.height = container.clientHeight || 300;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                
                reset();
                
                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (e.clientX - rect.left) * scaleX;
                    const mouseY = (e.clientY - rect.top) * scaleY;
                    
                    for (let i = 0; i < points.length; i++) {
                        const point = points[i];
                        const distance = Math.hypot(point.x - mouseX, point.y - mouseY);
                        if (distance < 15) {
                            draggingPoint = point;
                            draggingIndex = i;
                            canvas.style.cursor = 'grabbing';
                            break;
                        }
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (e.clientX - rect.left) * scaleX;
                    const mouseY = (e.clientY - rect.top) * scaleY;
                    
                    if (draggingPoint && draggingIndex >= 0) {
                        // æ›´æ–°æ‹–æ‹½ç‚¹ä½ç½®
                        draggingPoint.x = mouseX;
                        draggingPoint.y = mouseY;
                        
                        // ä¿æŒå‘¨é•¿ä¸å˜ï¼šè°ƒæ•´å…¶ä»–ç‚¹çš„ä½ç½®
                        maintainPerimeter();
                        draw();
                        updatePerimeterDisplay();
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨æ§åˆ¶ç‚¹ä¸Š
                        let hoveringPoint = false;
                        for (const point of points) {
                            if (Math.hypot(point.x - mouseX, point.y - mouseY) < 15) {
                                hoveringPoint = true;
                                break;
                            }
                        }
                        canvas.style.cursor = hoveringPoint ? 'grab' : 'default';
                    }
                });
                
                canvas.addEventListener('mouseup', () => { 
                    draggingPoint = null; 
                    draggingIndex = -1;
                    canvas.style.cursor = 'default';
                });
                canvas.addEventListener('mouseleave', () => { 
                    draggingPoint = null; 
                    draggingIndex = -1;
                    canvas.style.cursor = 'default';
                });
            }

            function calculatePerimeter() {
                if (points.length < 2) return 0;
                let perimeter = 0;
                for (let i = 0; i < points.length; i++) {
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    perimeter += Math.hypot(next.x - current.x, next.y - current.y);
                }
                return perimeter;
            }
            
            function maintainPerimeter() {
                if (points.length < 3 || draggingIndex < 0) return;
                
                const currentPerimeter = calculatePerimeter();
                const scaleFactor = FIXED_PERIMETER / currentPerimeter;
                
                // ä»¥æ‹–æ‹½ç‚¹ä¸ºä¸­å¿ƒï¼ŒæŒ‰æ¯”ä¾‹è°ƒæ•´å…¶ä»–ç‚¹çš„ä½ç½®
                const centerX = draggingPoint.x;
                const centerY = draggingPoint.y;
                
                for (let i = 0; i < points.length; i++) {
                    if (i !== draggingIndex) {
                        const dx = points[i].x - centerX;
                        const dy = points[i].y - centerY;
                        points[i].x = centerX + dx * scaleFactor;
                        points[i].y = centerY + dy * scaleFactor;
                    }
                }
            }
            
            function updatePerimeterDisplay() {
                const perimeter = calculatePerimeter();
                if (perimeterDisplay) {
                    perimeterDisplay.textContent = `å½“å‰å‘¨é•¿: ${Math.round(perimeter)}px`;
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (points.length === 0) return;
                
                // Draw line/shape
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (points.length > 2 && points[0].isClosed) {
                    ctx.closePath();
                }
                ctx.strokeStyle = '#e17055';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Draw control points
                for (const point of points) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#74b9ff';
                    ctx.fill();
                    ctx.strokeStyle = '#0984e3';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
            
            function reset() {
                const w = canvas.width || 400;
                const h = canvas.height || 300;
                points = [
                    { x: w * 0.1, y: h / 2, isClosed: false },
                    { x: w * 0.9, y: h / 2, isClosed: false },
                ];
                draw();
                updatePerimeterDisplay();
            }

            function setShape(shape) {
                const w = canvas.width;
                const h = canvas.height;
                if (shape === 'rect') {
                    // åˆ›å»ºä¸€ä¸ªå‘¨é•¿ä¸ºFIXED_PERIMETERçš„çŸ©å½¢
                    const rectWidth = FIXED_PERIMETER / 4;
                    const rectHeight = FIXED_PERIMETER / 4;
                    const centerX = w / 2;
                    const centerY = h / 2;
                    points = [
                        { x: centerX - rectWidth/2, y: centerY - rectHeight/2, isClosed: true }, 
                        { x: centerX + rectWidth/2, y: centerY - rectHeight/2 },
                        { x: centerX + rectWidth/2, y: centerY + rectHeight/2 }, 
                        { x: centerX - rectWidth/2, y: centerY + rectHeight/2 }
                    ];
                } else if (shape === 'circle') {
                    // åˆ›å»ºä¸€ä¸ªå‘¨é•¿ä¸ºFIXED_PERIMETERçš„åœ†å½¢
                    const radius = FIXED_PERIMETER / (2 * Math.PI);
                    points = [];
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const point = {
                            x: w/2 + radius * Math.cos(angle),
                            y: h/2 + radius * Math.sin(angle)
                        };
                        if (i === 0) point.isClosed = true;
                        points.push(point);
                    }
                }
                draw();
                updatePerimeterDisplay();
            }
            
            return { init, reset, setShape };
        })();
        
        // --- æ¨¡å—ä¸‰ï¼šé•¿æ–¹å½¢çš„ç§˜å¯† ---
        modules.module3 = (() => {
            const rectEl = document.getElementById('m3-rect');
            const handleEl = document.getElementById('m3-handle');
            const containerEl = document.getElementById('m3-rect-container');
            const lengthLabel = document.getElementById('m3-length-label');
            const widthLabel = document.getElementById('m3-width-label');
            const formulaEl = document.getElementById('m3-formula');
            const demoBtn = document.getElementById('m3-demo-btn');
            const rectModeBtn = document.getElementById('m3-rect-mode');
            const squareModeBtn = document.getElementById('m3-square-mode');
            
            const unit = 20; // 20px = 1 unit
            let isDragging = false;
            let isSquareMode = false;

            function init() {
                handleEl.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    containerEl.style.pointerEvents = 'none'; // Prevent flickering
                    document.body.style.cursor = 'nwse-resize';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const rect = containerEl.getBoundingClientRect();
                    let width = e.clientX - rect.left;
                    let height = e.clientY - rect.top;
                    
                    // Snap to grid
                    width = Math.round(width / unit) * unit;
                    height = Math.round(height / unit) * unit;
                    
                    // æ­£æ–¹å½¢æ¨¡å¼ä¸‹ä¿æŒå®½é«˜ç›¸ç­‰
                    if (isSquareMode) {
                        const size = Math.max(width, height);
                        width = size;
                        height = size;
                    }
                    
                    rectEl.style.width = `${Math.max(unit*2, width)}px`;
                    rectEl.style.height = `${Math.max(unit*2, height)}px`;
                    updateLabels();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    containerEl.style.pointerEvents = 'auto';
                    document.body.style.cursor = 'default';
                });
                
                // æ¨¡å¼åˆ‡æ¢äº‹ä»¶
                rectModeBtn.addEventListener('click', () => setMode(false));
                squareModeBtn.addEventListener('click', () => setMode(true));
                
                demoBtn.addEventListener('click', runDemo);
                updateLabels();
            }

            function setMode(squareMode) {
                isSquareMode = squareMode;
                
                // æ›´æ–°æŒ‰é’®æ ·å¼
                if (isSquareMode) {
                    rectModeBtn.className = 'control-button bg-white text-green-600 font-semibold py-1 px-3 rounded-lg border-2 border-green-300 text-sm';
                    squareModeBtn.className = 'control-button bg-green-500 text-white font-semibold py-1 px-3 rounded-lg text-sm';
                    
                    // åˆ‡æ¢åˆ°æ­£æ–¹å½¢æ—¶ï¼Œå°†çŸ©å½¢è°ƒæ•´ä¸ºæ­£æ–¹å½¢
                    const currentWidth = rectEl.offsetWidth;
                    const currentHeight = rectEl.offsetHeight;
                    const size = Math.max(currentWidth, currentHeight);
                    rectEl.style.width = `${size}px`;
                    rectEl.style.height = `${size}px`;
                } else {
                    rectModeBtn.className = 'control-button bg-green-500 text-white font-semibold py-1 px-3 rounded-lg text-sm';
                    squareModeBtn.className = 'control-button bg-white text-green-600 font-semibold py-1 px-3 rounded-lg border-2 border-green-300 text-sm';
                }
                
                updateLabels();
            }

            function updateLabels() {
                const width = rectEl.offsetWidth / unit;
                const height = rectEl.offsetHeight / unit;
                
                if (isSquareMode) {
                    lengthLabel.textContent = `è¾¹é•¿ = ${width}`;
                    widthLabel.textContent = `è¾¹é•¿ = ${width}`;
                    
                    formulaEl.innerHTML = `
                        <p>æ­£æ–¹å½¢å‘¨é•¿ = è¾¹é•¿ Ã— 4</p>
                        <p>= ${width} Ã— 4</p>
                        <p class="font-bold text-2xl">= ${width * 4}</p>
                    `;
                } else {
                    lengthLabel.textContent = `é•¿ = ${width}`;
                    widthLabel.textContent = `å®½ = ${height}`;
                    
                    formulaEl.innerHTML = `
                        <p>é•¿æ–¹å½¢å‘¨é•¿ = (é•¿ + å®½) Ã— 2</p>
                        <p>= (${width} + ${height}) Ã— 2</p>
                        <p class="font-bold text-2xl">= ${(width + height) * 2}</p>
                    `;
                }
            }

            function runDemo() {
                demoBtn.disabled = true;
                const width = rectEl.offsetWidth;
                const height = rectEl.offsetHeight;

                // Cleanup previous demo elements
                containerEl.querySelectorAll('.demo-piece').forEach(el => el.remove());

                if (isSquareMode) {
                    // æ­£æ–¹å½¢æ¼”ç¤ºï¼šå››æ¡ç›¸ç­‰çš„è¾¹
                    const side1 = createPiece(0, 0, width, 5, 'bg-red-500');
                    const side2 = createPiece(width-5, 0, 5, height, 'bg-red-500');
                    const side3 = createPiece(0, height-5, width, 5, 'bg-red-500');
                    const side4 = createPiece(0, 0, 5, height, 'bg-red-500');
                    
                    // å››æ¡è¾¹åˆ†åˆ«ç§»åŠ¨åˆ°ä¸åŒä½ç½®ï¼Œå±•ç¤º4ä¸ªç›¸ç­‰çš„è¾¹é•¿
                    setTimeout(() => {
                        side1.style.transform = `translateY(-${height/2 + 30}px)`;
                        side2.style.transform = `translate(${width/2 + 30}px, 0)`;
                    }, 500);
                    
                    setTimeout(() => {
                        side3.style.transform = `translateY(${height/2 + 30}px)`;
                        side4.style.transform = `translate(-${width/2 + 30}px, 0)`;
                    }, 1500);
                } else {
                    // é•¿æ–¹å½¢æ¼”ç¤ºï¼šé•¿å’Œå®½å„ä¸¤æ¡
                    const l1 = createPiece(0, 0, width, 5, 'bg-blue-500');
                    const w1 = createPiece(width-5, 0, 5, height, 'bg-green-500');
                    const l2 = createPiece(0, height-5, width, 5, 'bg-blue-500');
                    const w2 = createPiece(0, 0, 5, height, 'bg-green-500');
                    
                    setTimeout(() => {
                        l1.style.transform = `translateY(-${height/2 + 20}px)`;
                        w1.style.transform = `translate(calc(${width/2}px + 10px), 0)`;
                    }, 500);
                    
                    setTimeout(() => {
                        l2.style.transform = `translateY(${height/2 + 20}px)`;
                        w2.style.transform = `translate(calc(-${width/2}px - 10px), 0)`;
                    }, 1500);
                }

                setTimeout(() => {
                    demoBtn.disabled = false;
                }, 4000);
            }

            function createPiece(left, top, width, height, color) {
                const piece = document.createElement('div');
                piece.className = `demo-piece absolute ${color} transition-transform duration-1000 ease-in-out`;
                piece.style.left = `${left}px`;
                piece.style.top = `${top}px`;
                piece.style.width = `${width}px`;
                piece.style.height = `${height}px`;
                containerEl.appendChild(piece);
                return piece;
            }

            return { init, updateLabels };
        })();

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>
